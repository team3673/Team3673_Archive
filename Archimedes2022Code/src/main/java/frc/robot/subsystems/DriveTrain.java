// RobotBuilder Version: 4.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

// ROBOTBUILDER TYPE: Subsystem.

package frc.robot.subsystems;


// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS
import edu.wpi.first.wpilibj.CounterBase.EncodingType;
import edu.wpi.first.wpilibj.DriverStation;
import edu.wpi.first.wpilibj.Encoder;
import edu.wpi.first.wpilibj.SPI;
import edu.wpi.first.math.controller.PIDController;
import edu.wpi.first.wpilibj2.command.PIDSubsystem;
import edu.wpi.first.wpilibj.drive.DifferentialDrive;
import edu.wpi.first.wpilibj.motorcontrol.MotorControllerGroup;
import edu.wpi.first.wpilibj.motorcontrol.Spark;
import frc.robot.commands.*;
//import edu.wpi.first.wpilibj.livewindow.LiveWindow;
import edu.wpi.first.wpilibj2.command.SubsystemBase;
import frc.robot.Constants;
import frc.robot.Constants.DriveConstants;
import frc.robot.Constants.PIDConstants;

import com.kauailabs.navx.frc.AHRS;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS


/**
 *
 */
public class DriveTrain extends SubsystemBase {
	
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    private Spark rightFront;
    private Spark rightBack;
    private MotorControllerGroup rightMotors;
    private Spark leftFront;
    private Spark leftBack;
    private MotorControllerGroup leftMotors;
    private DifferentialDrive drive;
    private Encoder leftEncoder;
    private Encoder rightEncoder;


	AHRS gyro = new AHRS(SPI.Port.kMXP);
	PIDController turnController;
  	double rotateToAngleRate;

	

    public double getEncoderAverage(){
     // return (leftEncoder.get() + -rightEncoder.get()) / 2 * DriveConstants.kEncoderTick2Meter;
     return (leftEncoder.getDistance() + rightEncoder.getDistance()) / 2;
 
    }

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    
    /**
    *
    */
    public  DriveTrain() {
        
            // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
    rightFront = new Spark(3);
    addChild("Right Front",rightFront);
    rightFront.setInverted(false);

    rightBack = new Spark(2);
    addChild("Right Back",rightBack);
    rightBack.setInverted(false);

    rightMotors = new MotorControllerGroup(rightFront, rightBack  );
    addChild("Right Motors",rightMotors);
    

    leftFront = new Spark(0);
    addChild("Left Front",leftFront);
    leftFront.setInverted(true);

    leftBack = new Spark(1);
    addChild("Left Back",leftBack);
    leftBack.setInverted(true);

    leftMotors = new MotorControllerGroup(leftFront, leftBack  );
    addChild("Left Motors",leftMotors);

    

    drive = new DifferentialDrive(rightMotors, leftMotors);
    addChild("Drive",drive);
    drive.setSafetyEnabled(true);
    //drive.setExpiration(0.1);
    drive.setMaxOutput(1);
    drive.setDeadband(0.02);


    leftEncoder = new Encoder(2, 3, false, EncodingType.k4X);
    addChild("Left Encoder",leftEncoder);
    leftEncoder.setDistancePerPulse(Constants.DriveConstants.kEncoderDistancePerPulse);
    leftEncoder.reset();

    rightEncoder = new Encoder(0, 1, false, EncodingType.k4X);
    addChild("Right Encoder",rightEncoder);
    rightEncoder.setDistancePerPulse(Constants.DriveConstants.kEncoderDistancePerPulse);
    rightEncoder.reset();
    rightEncoder.setReverseDirection(true);
    







 
/*
 try {
	/***********************************************************************
	 * navX-MXP: - Communication via RoboRIO MXP (SPI, I2C) and USB. - See
	 * http://navx-mxp.kauailabs.com/guidance/selecting-an-interface.
	 * 
	 * navX-Micro: - Communication via I2C (RoboRIO MXP or Onboard) and USB. - See
	 * http://navx-micro.kauailabs.com/guidance/selecting-an-interface.
	 * 
	 * VMX-pi: - Communication via USB. - See
	 * https://vmx-pi.kauailabs.com/installation/roborio-installation/
	 * 
	 * Multiple navX-model devices on a single robot are supported.
	 ************************************************************************/
  /*
	gyro = new AHRS(SPI.Port.kMXP);
  } catch (RuntimeException ex) {
	DriverStation.reportError("Error instantiating navX MXP:  " + ex.getMessage(), true);
  }
  turnController = new PIDController(PIDConstants.kP, PIDConstants.kI, PIDConstants.kD);
  turnController.enableContinuousInput(-180.0f, 180.0f);
  */
  }

  public double getRightEncoder(){
    return rightEncoder.getDistance();//*13.3558*1.6*1.25*0.9

  }
  public double getLeftEncoder(){
    return leftEncoder.getDistance();
  }
/**
 * This function is called every robot packet, no matter the mode. Use this for
 * items like diagnostics that you want ran during disabled, autonomous,
 * teleoperated and test.
 *
 * <p>
 * This runs after the mode specific periodic functions, but before LiveWindow
 * and SmartDashboard integrated updating.
 */
  

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
    



    @Override
    public void periodic() {
        // This method will be called once per scheduler run

    }

    @Override
    public void simulationPeriodic() {
        // This method will be called once per scheduler run when in simulation

    }
    // Only Use for tele
    public void drive(double left, double right) {
        drive.tankDrive(right, left);
    }
    public void stop(){
        drive.tankDrive(0.0,0.0);
        
    }
    // Put methods for controlling this subsystem
    // here. Call these from Commands.
    
    // Only use for Auto

    public void setMotors(double leftSpeed, double rightSpeed) {
    // Assuming no wheel slip, the difference in encoder distances is proportional to the heading error
    double error = rightEncoder.getDistance() - leftEncoder.getDistance();

    // Drives forward continuously at half speed, using the encoders to stabilize the heading
    
        leftMotors.set(leftSpeed - Constants.PIDConstants.kP * error );
        rightMotors.set(rightSpeed + Constants.PIDConstants.kP * error);
       
    }



}

